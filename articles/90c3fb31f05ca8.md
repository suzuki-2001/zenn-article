---
title: "Atcoder B: ”A to Z String”を簡単に解く"
emoji: "✨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Atcoder", "cpp"]
published: true
---

# find(), rfind()

文字列の位置を取得します。`find()`は前から検索し、`rfind()`は後ろから検索します。
どちらも検索した際に最初にヒットした際の位置を返します。

これをうまく使える問題がAtcoderのB問題にありました。
[Atcoder B - A to Z String](https://atcoder.jp/contests/abc053/tasks/abc053_b)

> すぬけくんは文字列 s の連続した一部分(部分文字列という)を取り出して先頭が `A` であり末尾が `Z` であるような文字列を作ることにしました。 すぬけくんが作ることのできる文字列の最大の長さを求めてください。 なお，s には先頭が `A` であり末尾が `Z` であるような部分文字列が必ず存在することが保証されます。
> 
> 制約
> ・  1≦∣s∣≦200,000
> ・  s は英大文字のみからなる
> ・  s には先頭が `A` であり末尾が `Z` であるような部分文字列が必ず存在する

要は最初に現れたAから、最後に現れたZまでで何文字ありますか？というような問題ですね。

***
入力例：
```
HASFJGHOGAKZZFEGA
```

出力例：
```
12
```
***
このようなケースだとZが連続しています。文字列の最大の長さを取る必要があるため、ここでは
`ASFJGHOGAKZZ`の長さを返す必要があります。

このとき、`rfind()`を使用してやれば簡単に最大長を取得することができます。
お題が文字列の長さなので、実装は以下です。

```cpp:
#include <bits/stdc++.h>
using namespace std;

int main() {
  string s;
  cin >> s;
  
  int start = s.find('A');
  int end = s.rfind('Z');
  
  int ans = (end - start) + 1;
  cout << ans << endl;
}
